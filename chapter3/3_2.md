## 3.2 非決定性有限オートマトン
- これまでの仮定や制約を少しずつ取り除いていく
  - 関心の無い文字に関する規則をなくして、想定外のことが起きると失敗状態になるという様にするとどうなるか
  - 機械が矛盾する規則を持つことを許して、複数の実行パスを可能にするとどうなるか
  - 何も読まなくても状態を変更できると、どうなるか
  
### 3.2.1 非決定性

- 頭から3番目がbなら受理するDFAは簡単
- 最後から3番目がbなら受理するDFAは作れない
  - 最後から3番目だと思っても、実際はいくつ続くかわからない
- 規則を緩和してbが来たときに、その状態に留まるか、次の状態に遷移するか、曖昧にすることでこの機械を設計できる
- この状態機械を**非決定性有限オートマトン(NFA)**と呼ぶ
- 入力シーケンスに対して複数の実行パスが持てる
- DAFは盲目的に入力シーケンスを読んだ
- NFAは受理状態になる**何らか**のパスがあれば受理される
  - 必ず怒らなくても受理状態で終わる可能性があれば受理される
- 協力なように見えるが、現実世界でどう動くか
  - 入力を読みながら何らかの予測が必要になるのか？
  - そんなことはない
- NFAのシミュレートで重要なことは、その機械のすべての可能な実行を見つけること
- NFAが文字を読むとき、次に移動する可能性のある状態は有限個
- すべての可能性を再帰的に試していくことで実現できる
- 全探索
- スレッド立てて並行で探索してもよい
- 実装は楽だが効率よくない
- もっと簡単にできる
- 取り得る現在の値をすべて記録することでNFAをシミュレートできる
- DFAは特定の文字を読んで、次にどこに移動するか返す
- NFAは特定の文字を読んで、次にどの状態にいるのか、可能性のある状態すべてを返す

### 3.2.2 自由移動

- 2か3の倍数の文字列を受理する機械を設計したい
- NFAで書いてもできない
- **自由移動**を導入することで実現できる
- 何も入力を読まずに自発的にしたがうことのできる規則
- 2の倍数を受理するNFAと3の倍数を受理するNFAを自由移動のノードで繋げる
